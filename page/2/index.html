<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="../../css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="HHcola">
<meta property="og:url" content="http://HHcola.github.io/page/2/index.html">
<meta property="og:site_name" content="HHcola">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HHcola">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://HHcola.github.io/page/2/"/>





  <title> HHcola </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HHcola</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://HHcola.github.io../../2017/04/10/Gson-Parse-One/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HHcola">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HHcola">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="../../2017/04/10/Gson-Parse-One/" itemprop="url">
                  Gson性能分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T11:05:33+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeAdapter会比使用JsonSerializer和JsonDeserializer更加的高效，原理是怎么样的呢？性能提升明显吗？</p>
<h1 id="Gson性能分析"><a href="#Gson性能分析" class="headerlink" title="Gson性能分析"></a>Gson性能分析</h1><p>首先来看看我们提供一个大一点的数据来论证下面一些方法的优缺点。 这里提供类LargeData.java,并分为四个部分进行内存消耗的分析：</p>
<pre>
public class LargeData {

  private long[] numbers;

  public void create(final int length) {
    numbers = new long[length];
    for (int i = 0; i < length; i++) {
      numbers[i] = i;
    }
  }

  public long[] getNumbers() {
    return numbers;
  }

}
</pre>

<h2 id="第1部分-JsonSerializer的直接使用"><a href="#第1部分-JsonSerializer的直接使用" class="headerlink" title="第1部分 JsonSerializer的直接使用"></a>第1部分 JsonSerializer的直接使用</h2><p>看看下面的JsonSerializer:</p>
<pre>
package com.javacreed.examples.gson.part1;

import java.lang.reflect.Type;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class LargeDataSerialiser implements JsonSerializer<largedata> {

  @Override
  public JsonElement serialize(final LargeData data, final Type typeOfSrc, final JsonSerializationContext context) {
    final JsonArray jsonNumbers = new JsonArray();
    for (final long number : data.getNumbers()) {
      jsonNumbers.add(new JsonPrimitive(number));
    }
    final JsonObject jsonObject = new JsonObject();
    jsonObject.add("numbers", jsonNumbers);
    return jsonObject;
  }
}
</largedata></pre>

<p>上面的代码实现了从java对象&gt;转化&gt;JSON数组的序列化过程。下面的代码实现了配置和初始化的过程，被写入文件。这里可以看到的是对LargeData初始化了10485760个元素：</p>
<pre>
package com.javacreed.examples.gson.part1;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final String json = gson.toJson(data);

    final File dir = new File("target/part1");
    dir.mkdirs();

    try (PrintStream out = new PrintStream(new File(dir, "output.json"), "UTF-8")) {
      out.println(json);
    }

    System.out.println("Done");
  }
}
</pre>


<p>这个例子实现了创建java对象并且转化为JSON字符串并写入文件的整个过程。下面的图标展示了内存的消耗情况：</p>
<p><img src="Gson-Parse-One/JsonSerializer.png" alt="ser"><br>上面的的LargeData在这里会消耗89MB的内存，从java对象转化为JSON字符串的过程将会消耗大概16s的时间并且需要超过1GB的内存。也就是说，序列化1MB的数据我们需要大约11MB的工作空间。1：11的确实是一个不小的比列。下面的 图片会展示整个过程的几个阶段。<br><img src="Gson-Parse-One/serializer-one.png" alt="ser"></p>
<p>可以看到的是，这里有四个方块分别代表不同的阶段，（但是IO 缓冲区并没有在这里得到使用，所以以灰色进行标注。）整个过程从java对象（蓝色方块），然后由LargeDataSerialiser类创建的JSONElement对象（红色方块），然后这些临时的对象又被转化为JSON 字符串（绿色方块），上面的示例代码使用PrintStream将内容输出到文件中并没有使用任何缓冲区。</p>
<p>完成了第1部分的分析，接下来下面的分析流程是一样的：</p>
<h2 id="第2-部分-TypeAdapter的直接使用"><a href="#第2-部分-TypeAdapter的直接使用" class="headerlink" title="第2 部分 TypeAdapter的直接使用"></a>第2 部分 TypeAdapter的直接使用</h2><p>之前的系列文章中都对Gson基础的使用进行了很好的讲解，可以回顾一下。</p>
<p>TypeAdapter相比 于上面的方法，并没有使用JSONElement对象，而是直接将Java对象啊转化为了JSON对象。</p>
<pre>
package com.javacreed.examples.gson.part2;

import java.io.IOException;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

public class LargeDataTypeAdapter extends TypeAdapter<largedata> {

  @Override
  public LargeData read(final JsonReader in) throws IOException {
    throw new UnsupportedOperationException("Coming soon");
  }

  @Override
  public void write(final JsonWriter out, final LargeData data) throws IOException {
    out.beginObject();
    out.name("numbers");
    out.beginArray();
    for (final long number : data.getNumbers()) {
      out.value(number);
    }
    out.endArray();
    out.endObject();
  }
}
</largedata></pre>

<p>同样会需要配置，这里主要使用的方法是<br>gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());</p>
<pre>
package com.javacreed.examples.gson.part2;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final String json = gson.toJson(data);

    final File dir = new File("target/part2");
    dir.mkdirs();

    try (PrintStream out = new PrintStream(new File(dir, "output.json"), "UTF-8")) {
      out.println(json);
    }

    System.out.println("Done");
  }
}
</pre>
上面的代码完成的是从java对象 >转化>JSON 字符串并最终写入文件的过程。看看下面的性能分析图表：
![ser](Gson-Parse-One/typeadapter.png)

和最初的那个方法一样，这里的LargeData对象将会需要89MB的内存，从java对象转化为JSON字符串的过程需要消耗4s的时间，大概650MB的内存。也就是说，序列化1MB的数据，大概需要7.5MB的内存空间。相比于之前的第一种JsonSerializer方法，这里减少了接近一半的内存消耗。同样的，来看看这个方法的几个过程：
![ser](Gson-Parse-One/typeadapter-one.png)

这里的序列化过程主要有两个阶段，相比于之前的JSONSerializer的序列化过程，这里没有了转化为JSONElement的过程，也就完成了内存消耗的减少。

##第3部分 TypeAdapter的流式处理
下面的代码，我们使用上面同样的TypeAdapter，只不过我们直接在main()方法中修改Gson的用法，以流的形式进行输出。

<pre>
package com.javacreed.examples.gson.part3;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final File dir = new File("target/part3");
    dir.mkdirs();

    try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(dir,
        "output.json")), "UTF-8"))) {
      gson.toJson(data, out);
    }

    System.out.println("Done");
  }
}
</pre>

<p>这个例子同样是将java对象转化为JSON字符串并且输出，也来看看下面的性能分析图表：<br><img src="Gson-Parse-One/typeadapter-liu.png" alt="ser"><br>可以看到的是同样的最初产生的数据是89MB,序列化过程将java对象转化为JSON字符串花了大概三秒钟的时间，消耗大概160MB的内存。也就是说序列化1MB的数据我们需要大概2MB的内存空间。相比于之前的两种方法，有了很大的改进。<br><img src="Gson-Parse-One/typeadapter-liu-one.png" alt="ser"></p>
<p>TypeAdapter-with-Stream-Stages<br>这个方法同样的是使用了两个阶段。不过在上面一个示例中的绿色方块部分在这里没有使用，这里直接完成了java对象到IO 缓冲区的转化并写入文件。</p>
<p>虽然这里并不是Gson的关系，但是我们使用Gson的方法极大的减少了内存消耗，所以说在使用开源库的时候，能够正确高效的使用API也显得尤为重要。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在上面的分析过程中，我们采用了GSON的两种不同的方然完成了序列化一个大数据的过程，并且比较了不同的方法之间的差异。上面的第三种方法（TypeAdapter的流式处理）被论证为最合适的，消耗最少内存的一种方法。</p>
<p>Gson主要分成两部分,一个就是数据拆解,一个是数据封装</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://HHcola.github.io../../2017/04/09/hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HHcola">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HHcola">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="../../2017/04/09/hexo/" itemprop="url">
                  hexo 使用指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T02:01:54+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>安装Hexo</p>
<p>安装Nodejs<br>Mac用户和Windows用户安装比较简单，直接下载Node.js按照默认配置安装即可。Linux用户下载编译后的文件解压后即可使用（在其bin文件夹下有npm和node的命令工具）。为了方便起见，Linux用户还需要使用ln命令将node和npm设为全局生效：</p>
<pre>
$ ln -s /解压目录/bin/node /usr/local/bin/npm
$ ln -s /解压目录/bin/npm /usr/local/bin/npm
</pre>

<p>安装完成后打开命令行工具（Windows用户在开始菜单打开Node.js文件夹下的Node.js command prompt）进行接下来的操作。</p>
<p>更改npm源</p>
<pre>
$ npm config set registry https://registry.npm.taobao.org npm info underscore
</pre>

<p>国外的NPM源并不稳定，即使翻墙也不一定能将Hexo下载下来，所以这里直接更改为淘宝源。</p>
<p>安装hexo</p>
<p><pre><br>$ npm install -g hexo-cli<br></pre><br>这里安装的是hexo最新版本，如果想安装以前的的版本请运行命令$ npm </p>
<p><pre><br>install -g hexo<br></pre><br>以上步骤不出问题的话就已经在本地机器上搭建起了Hexo环境。下面介绍Hexo的具体使用方法。</p>
<p>Quick Start</p>
<p>创建hexo工程</p>
<p><pre>$ hexo init blog</pre><br>创建一个文件夹blog（此处blog换成你自己想要的名字），使用Hexo命令初始化blog为hexo工程目录。</p>
<p>新建POST</p>
<p><pre>$ cd blog<br>$ hexo new “HelloWorld”</pre><br>进入初始化后的blog文件夹，创建名为HelloWorld的文件，此时会在/blog/sources/_post/目录下生成HelloWorld.md文件。</p>
<p>生成静态文件</p>
<p><pre>$ hexo generate</pre><br>使用Hexo引擎将Markdown格式的文件解析成可以使用浏览器查看的HTML文件，HTML文件存储在blog/public目录下。</p>
<p>运行hexo服务器</p>
<p><pre>$ hexo server</pre><br>打开命令行提示的地址，一般是<a href="http://0.0.0.0:4000/，既可以看到我们的Hexo网站。如果提示找不到server命令则需要运行命令" target="_blank" rel="external">http://0.0.0.0:4000/，既可以看到我们的Hexo网站。如果提示找不到server命令则需要运行命令</a></p>
<p><pre>$ npm install hexo-server –save，Hexo3.0之后把server</pre>独立出来了，所以需要单独安装。</p>
<p>此时Helloworld文章中没有任何内容。打开/blog/sources/_post/目录，使用编辑器打开其中的HelloWorld.md并在其中添加markdown格式的内容保存，然后重新运行以下命令：</p>
<p><pre>$ hexo generate<br>$ hexo server</pre><br>打开浏览器查看修改后的内容。以后创建并查看新的POST，运行以下命令即可：</p>
<p><pre><br>$ hexo new “your post name”<br>$ hexo generate<br>$ hexo server<br></pre><br>安装主题</p>
<p>Hexo提供了默认主题landscape。如果想要使用别人的主题则需要用到Git工具。Windows用户和Mac用户安装Git都比较简单，Windows用户登录git官网下载软件安装，Mac用户只需在命令行中键入Git命令就会自动提示安装（详细安装教程请移步Git）。安装完成后打开命令行工具（Windows用户打开开始菜单Git目录下的Git Bash）。</p>
<p><pre><br>$ cd /blog/themes<br>$ git clone <a href="https://github.com/wuchong/jacman.git" target="_blank" rel="external">https://github.com/wuchong/jacman.git</a> ./jacman<br>$ cd ./jacman<br>$ git pull<br></pre><br>然后在修改/blog/config.yml文件，将其中的theme改成jacman</p>
<p>theme: jacman<br>重新运行以下命令，查看更换主题后的效果</p>
<p><pre><br>$ hexo generate<br>$ hexo server<br></pre><br>这里有一些常见的hexo主题，读者可以挑选自己喜欢的安装。</p>
<p>接下来我们将本地Hexo上传到Github免费静态内容空间中，并使用域名访问网站。</p>
<p>申请Github免费静态内容空间</p>
<p>打开Github网站注册账号（账户创建和配置）并使用设置的用户名创建一个Repository。点击网站右上角的+号，选择New Repository</p>
<p>创建仓库</p>
<p>注意Repository Name必须和你设置的用户名一致。其他默认，确定创建。</p>
<p>设置参数<br>此时专属于你的静态内容空间就已经创建好了。在浏览器中输入your username.github.io即可访问。</p>
<p>创建成功<br>将Hexo上传到Github上</p>
<p>安装deployer-git</p>
<p><pre><br>$ npm install hexo-deployer-git –save<br></pre><br>在/blog/_config.yml中修改deploy属性(注意:之后有空格)</p>
<p><pre><br>deploy:<br>  type: git<br>  repository: <a href="https://github.com/thesingularityisnear/thesingularityisnear.github.io.git" target="_blank" rel="external">https://github.com/thesingularityisnear/thesingularityisnear.github.io.git</a><br>  branch: master<br>  </pre><br>将Repository换成你申请的Git仓库地址</p>
<p>repository地址</p>
<p>使用https的方式部署每次提交到Github都要输入用户名和密码，如果嫌麻烦请使用SSH的方式请移步到Git教程。</p>
<p>运行一下命令将Hexo上传到Github</p>
<p><pre><br>$ hexo generate<br>$ hexo deploy<br></pre><br>使用域名访问Hexo</p>
<p>购买个人域名<br>可以选择在万网或者godady上购买域名。各有利弊。不过考虑到只是用来做个人网站的域名，为了方便建议在万网购买。</p>
<p>解析域名<br>域名服务商都会提供相关解析服务，域名解析配置均相同</p>
<p>参数配置<br>绑定独立域名<br>进入blog/source文件夹，创建名为CNAME的文件</p>
<p>CNAME</p>
<p>运行以下命令</p>
<p><pre><br>$ hexo generate<br>$ hexo deploy<br></pre><br>OK，快试试用你的独立域名访问Hexo吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://HHcola.github.io../../2017/04/09/user-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HHcola">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HHcola">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="../../2017/04/09/user-hexo/" itemprop="url">
                  在 hexo 中使用本地图片
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T01:57:39+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.首先确认_config.yml 中有 post_asset_folder:true。<br>Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder<br>当您设置post_asset_folder为true参数后，在建立文件时，Hexo<br>会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p>
<p>2.在hexo的目录下执行npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">https://github.com/CodeFalling/hexo-asset-image</a> –save（需要等待一段时间）。</p>
<p>3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下：</p>
<p>本地图片测试<br>├── apppicker.jpg<br>├── logo.jpg<br>└── rules.jpg<br>本地图片测试.md<br>这样的目录结构（目录名和文章名一致），只要使用 <pre>(本地图片测试/logo.jpg)</pre> 就可以插入图片。其中[]里面不写文字则没有图片标题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://HHcola.github.io../../2017/04/09/Handler-Looper-Message-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HHcola">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HHcola">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="../../2017/04/09/Handler-Looper-Message-0/" itemprop="url">
                  Handler-Looper-Message
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T01:48:33+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p>Handler、Looper、Message可谓android中最基本的消息处理机制，但是要理清这三者关系需要一定的研究。本文从java层和native层深入探讨一下这里面的关系。</p>
<p>##Java层理解<br>Native层关系图：<br><img src="Handler-Looper-Message-0/message-java.jpg" alt="关系图"></p>
<p>###实例<br>先展示一个典型的例子：</p>
<pre>
class LooperThread extends Thread {
    public Handler mHandler;
    public void run() {
        Looper.prepare();  
        mHandler = new Handler() { 
            public void handleMessage(Message msg) {
                //TODO    定义消息处理逻辑
            }
        };
        Looper.loop(); 
    }
}
</pre>

<p>###消息发送图：<br><img src="Handler-Looper-Message-0/java_sendmessage.png" alt="消息图"></p>
<p>###消息流程图：<br><img src="Handler-Looper-Message-0/message-looper.jpg" alt="流程图"></p>
<p>图解：</p>
<p>####Handler通过sendMessage()发送Message到MessageQueue队列；</p>
<p>####Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；</p>
<p>####经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。</p>
<p>####将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。</p>
<p>###消息分发的优先级：</p>
<pre>
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        //当Message存在回调方法，回调msg.callback.run()方法；
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            //当Handler存在Callback成员变量时，回调方法handleMessage()；
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        //Handler自身的回调方法handleMessage()
        handleMessage(msg);
    }
}
</pre>
从消息分发代码中能够分析出消息分发优先级：
####Message的回调方法：message.callback.run()，优先级最高；
####Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于1；
####Handler的默认方法：Handler.handleMessage(msg)，优先级最低。

##Native层理解
java层的MessageQueue类里面涉及到多个native方法，除了MessageQueue的native方法，native层本身也有一套完整的消息机制，用于处理native的消息。在整个消息机制中，而MessageQueue是连接Java层和Native层的纽带，换言之，Java层可以向MessageQueue消息队列中添加消息，Native层也可以向MessageQueue消息队列中添加消息。

Native层关系图：
![关系图](Handler-Looper-Message-0/message-native.png)

###MessageQueue
在MessageQueue中的native方法如下：
<pre>
private native static long nativeInit();
private native static void nativeDestroy(long ptr);
private native void nativePollOnce(long ptr, int timeoutMillis);
private native static void nativeWake(long ptr);
private native static boolean nativeIsPolling(long ptr);
private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);
</pre>

<p>初始化过程的调用链如下：</p>
<p><img src="Handler-Looper-Message-0/native_init.png" alt="init"><br>其中epoll_create/epoll_ctl源码如下：</p>
<pre>
void Looper::rebuildEpollLocked() {
    if (mEpollFd >= 0) {
        close(mEpollFd); //关闭旧的epoll实例
    }
    mEpollFd = epoll_create(EPOLL_SIZE_HINT); //创建新的epoll实例，并注册wake管道
    struct epoll_event eventItem;
    memset(& eventItem, 0, sizeof(epoll_event)); //把未使用的数据区域进行置0操作
    eventItem.events = EPOLLIN; //可读事件
    eventItem.data.fd = mWakeEventFd;
    //将唤醒事件(mWakeEventFd)添加到epoll实例(mEpollFd)
    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);
    for (size_t i = 0; i < mRequests.size(); i++) {
        const Request& request = mRequests.valueAt(i);
        struct epoll_event eventItem;
        request.initEventItem(&eventItem);
        //将request队列的事件，分别添加到epoll实例
        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, & eventItem);
        if (epollResult < 0) {
            ALOGE("Error adding epoll events for fd %d while rebuilding epoll set, errno=%d", request.fd, errno);
        }
    }
}
</pre>

<p>这里为什么会用epoll而不是poll、select？</p>
<p>这里重要的方法是pollinner,重点看一下这个方法：</p>
<pre>
int Looper::pollInner(int timeoutMillis) {
    ...
    int result = POLL_WAKE;
    mResponses.clear();
    mResponseIndex = 0;
    mPolling = true; //即将处于idle状态
    struct epoll_event eventItems[EPOLL_MAX_EVENTS]; //fd最大个数为16
    //等待事件发生或者超时，在nativeWake()方法，向管道写端写入字符，则该方法会返回；
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
    mPolling = false; //不再处于idle状态
    mLock.lock();  //请求锁
    if (mEpollRebuildRequired) {
        mEpollRebuildRequired = false;
        rebuildEpollLocked();  // epoll重建，直接跳转Done;
        goto Done;
    }
    if (eventCount < 0) {
        if (errno == EINTR) {
            goto Done;
        }
        result = POLL_ERROR; // epoll事件个数小于0，发生错误，直接跳转Done;
        goto Done;
    }
    if (eventCount == 0) {  //epoll事件个数等于0，发生超时，直接跳转Done;
        result = POLL_TIMEOUT;
        goto Done;
    }
    //循环遍历，处理所有的事件
    for (int i = 0; i < eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeEventFd) {
            if (epollEvents & EPOLLIN) {
                awoken(); //已经唤醒了，则读取并清空管道数据【7】
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex >= 0) {
                int events = 0;
                if (epollEvents & EPOLLIN) events |= EVENT_INPUT;
                if (epollEvents & EPOLLOUT) events |= EVENT_OUTPUT;
                if (epollEvents & EPOLLERR) events |= EVENT_ERROR;
                if (epollEvents & EPOLLHUP) events |= EVENT_HANGUP;
                //处理request，生成对应的reponse对象，push到响应数组
                pushResponse(events, mRequests.valueAt(requestIndex));
            }
        }
    }
Done: ;
    //再处理Native的Message，调用相应回调方法
    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope& messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime <= now)="" {="" sp<messagehandler=""> handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();  //释放锁
                handler->handleMessage(message);  // 处理消息事件
            }
            mLock.lock();  //请求锁
            mSendingMessage = false;
            result = POLL_CALLBACK; // 发生回调
        } else {
            mNextMessageUptime = messageEnvelope.uptime;
            break;
        }
    }
    mLock.unlock(); //释放锁
    //处理带有Callback()方法的Response事件，执行Reponse相应的回调方法
    for (size_t i = 0; i < mResponses.size(); i++) {
        Response& response = mResponses.editItemAt(i);
        if (response.request.ident == POLL_CALLBACK) {
            int fd = response.request.fd;
            int events = response.events;
            void* data = response.request.data;
            // 处理请求的回调方法
            int callbackResult = response.request.callback->handleEvent(fd, events, data);
            if (callbackResult == 0) {
                removeFd(fd, response.request.seq); //移除fd
            }
            response.request.callback.clear(); //清除reponse引用的回调方法
            result = POLL_CALLBACK;  // 发生回调
        }
    }
    return result;
}
</=></pre>

<p>这里后面处理的message，是native层的消息，并不是java层发送的message。<br>具体代码如下：</p>
<p><pre><br>void Looper::sendMessageAtTime(nsecs_t uptime, const sp<messagehandler>&amp; handler,<br>        const Message&amp; message) {<br>#if DEBUG_CALLBACKS<br>    ALOGD(“%p ~ sendMessageAtTime - uptime=%lld, handler=%p, what=%d”,<br>            this, uptime, handler.get(), message.what);<br>#endif<br>    size_t i = 0;<br>    { // acquire lock<br>        AutoMutex _l(mLock);<br>        size_t messageCount = mMessageEnvelopes.size();<br>        while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) {<br>            i += 1;<br>        }<br>        MessageEnvelope messageEnvelope(uptime, handler, message);<br>        mMessageEnvelopes.insertAt(messageEnvelope, i, 1);<br>        // Optimization: If the Looper is currently sending a message, then we can skip<br>        // the call to wake() because the next thing the Looper will do after processing<br>        // messages is to decide when the next wakeup time should be.  In fact, it does<br>        // not even matter whether this code is running on the Looper thread.<br>        if (mSendingMessage) {<br>            return;<br>        }<br>    } // release lock<br>    // Wake the poll loop only when we enqueue a new message at the head.<br>    if (i == 0) {<br>        wake();<br>    }<br>}<br></messagehandler></pre><br>这里会对mMessageEnvelopes队列进行插入message消息，属于native层的消息。</p>
<h3 id="nativeWake"><a href="#nativeWake" class="headerlink" title="nativeWake()"></a>nativeWake()</h3><p>nativeWake用于唤醒功能，在添加消息到消息队列enqueueMessage(), 或者把消息从消息队列中全部移除quit()，再有需要时都会调用 nativeWake方法。包含唤醒过程的添加消息的调用链，如下：<br><img src="Handler-Looper-Message-0/native_wake.png" alt="nativeWake"></p>
<p>最终会唤醒epoll_wait，进行消息的分发处理。</p>
<p>###小结<br>本节介绍MessageQueue的native()方法，经过层层调用：</p>
<p>nativeInit()方法，最终实现由epoll机制中的epoll_create()/epoll_ctl()完成；<br>nativeDestroy()方法，最终实现由RefBase::decStrong()完成；<br>nativePollOnce()方法，最终实现由Looper::pollOnce()完成；<br>nativeWake()方法，最终实现由Looper::wake()调用write方法，向管道写入字符；<br>nativeIsPolling()，nativeSetFileDescriptorEvents()这两个方法类似，</p>
<p>##总结</p>
<p>MessageQueue通过mPtr变量保存NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息；下面列举Java层与Native层的对应图<br><img src="Handler-Looper-Message-0/handler_arch.png" alt="arch"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://HHcola.github.io../../2017/03/30/tensorflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HHcola">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HHcola">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="../../2017/03/30/tensorflow/" itemprop="url">
                  tensorflow
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-30T23:24:25+08:00">
                2017-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="tensorflow-介绍"><a href="#tensorflow-介绍" class="headerlink" title="tensorflow 介绍"></a>tensorflow 介绍</h2><p>Tensorflow 最初是由Google大脑小组的研究员和工程师们开发出来，用语机器学习和深度神经网络方面的研究，于2015.11.09号开源。</p>
<p><a href="https://www.tensorflow.org/" target="_blank" rel="external">tensorflow 官网</a> <br><br><a href="http://www.tensorfly.cn/" target="_blank" rel="external">tensorflow 中文社区</a></p>
<p>后续的文章会介绍tensorflow on android 以及在python上的编译。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://HHcola.github.io../../2017/03/30/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HHcola">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HHcola">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="../../2017/03/30/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-30T18:56:44+08:00">
                2017-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>dog</th>
<th>bird</th>
<th>cat</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>foo</td>
<td>foo</td>
</tr>
<tr>
<td>bar</td>
<td>bar</td>
<td>bar</td>
</tr>
<tr>
<td>baz</td>
<td>baz</td>
<td>baz</td>
</tr>
<tr>
<td>ttt</td>
<td>ddd</td>
<td>xxx</td>
</tr>
</tbody>
</table>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="../../index.html"><i class="fa fa-angle-left"></i></a><a class="page-number" href="../../index.html">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="../../images/avatar.gif"
               alt="HHcola" />
          <p class="site-author-name" itemprop="name">HHcola</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="../../archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HHcola</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="../../lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="../../lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="../../js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="../../js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="../../js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
